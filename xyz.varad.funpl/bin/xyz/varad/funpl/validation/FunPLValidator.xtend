/*
 * generated by Xtext 2.14.0
 */
package xyz.varad.funpl.validation

import org.eclipse.xtext.validation.Check
import com.google.inject.Inject
import xyz.varad.funpl.util.FunPLModelUtil
import xyz.varad.funpl.funPL.FunPLPackage
import xyz.varad.funpl.funPL.SymbolRef
import xyz.varad.funpl.funPL.Symbol
import xyz.varad.funpl.funPL.Definition
import static extension xyz.varad.funpl.util.FunPLModelUtil.*

import static extension org.eclipse.xtext.EcoreUtil2.*
import xyz.varad.funpl.funPL.Function
import xyz.varad.funpl.funPL.FunProgram
import java.util.List
import xyz.varad.funpl.funPL.Value
import xyz.varad.funpl.funPL.FunctionParam
import xyz.varad.funpl.funPL.Assignment
import xyz.varad.funpl.funPL.Plus
import xyz.varad.funpl.typing.FunPLTypeProvider
import xyz.varad.funpl.funPL.Type
import java.util.ArrayList
import java.util.HashSet
import xyz.varad.funpl.funPL.FunctionCall

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FunPLValidator extends AbstractFunPLValidator {
	// FIXME disable def. references in global scope???
	// FIXME non-void function should have return statement (when if-else added) 
	// FIXME function call signature stringRepr e.g. foo(int, int, string)
		
	static val ISSUE_CODE_PREFIX = "xyz.varad.funpl."
	public static val SYMBOL_REDEFINITION = ISSUE_CODE_PREFIX + "SymbolRedefinition"
	public static val INVALID_VALUE_DEFINITION = ISSUE_CODE_PREFIX + "InvalidValueDefinition"
	public static val INVALID_ASSIGNMENT = ISSUE_CODE_PREFIX + "InvalidAssignment"
	public static val INVALID_ADDITION = ISSUE_CODE_PREFIX + "InvalidAddition"
	public static val AMBIGUOUS_RETURN_TYPE = ISSUE_CODE_PREFIX + "AmbiguousReturnType"
	public static val MISSING_RETURN_STATEMENT = ISSUE_CODE_PREFIX + "MissingReturnStatement"
	public static val CONSTANT_REASSIGNMENT = ISSUE_CODE_PREFIX + "ConstantReassignment"
	public static val UNDEFINED_CONSTANT = ISSUE_CODE_PREFIX + "UndefinedConstant"
	public static val INVALID_FUNCTION_CALL = ISSUE_CODE_PREFIX + "InvalidFunctionCall"
	
	@Inject extension FunPLModelUtil
	@Inject extension FunPLTypeProvider
	
	/////////////////////////////////SCOPING-RELATED RULES/////////////////////////////////////////////
	
	@Check
	def void checkSymbolRedefinitionAsNeighbor(Definition _d){
		val contProg = _d.getContainerOfType(FunProgram)
		val contFunc = _d.getContainerOfType(Function)
		if(contFunc !== null && !(_d instanceof Function)){
			if(contFunc.symbols.takeWhile[it != _d].containsSameNamedSymbol(_d)){
				error("Symbol redefinition not allowed: '" + _d.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_d.name)
			}
		}else{
			if(contProg.symbols.takeWhile[it != _d].containsSameNamedSymbol(_d)){
				error("Symbol redefinition not allowed: '" + _d.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_d.name)
			}
		}
	}
	
	@Check
	def void checkSymbolRedefinitionParam(FunctionParam _p){
		val contFunc = _p.getContainerOfType(Function)
		if(contFunc !== null){
			if(contFunc.params.takeWhile[it != _p].containsSameNamedSymbol(_p)){
				error("Symbol redefinition not allowed: '" + _p.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_p.name)
			}
		}
	}
	
	//////////////////////////////////EXPRESSION AND TYPING-RELATED RULES//////////////////////////////////////////
	
	@Check
	def void checkValueDefinitionValidity(Value _v){
		if(_v.expression !== null){
			if(!(_v.typeFor.isSame(_v.expression.typeFor))){
				error("The operation is undefined for argument type(s) " + _v.typeFor.typeString + ", " + _v.expression.typeFor.typeString,
					null,
					INVALID_VALUE_DEFINITION
				)
			}
		}else if(_v.typeFor === null){
			error("The value '" + _v.name + "' must either have a declared type or be initialized",
					null,
					INVALID_VALUE_DEFINITION
				)
		}
	}
	
	@Check
	def void checkAssignmentExpressionValidity(Assignment _a){
		if(!(_a.left instanceof SymbolRef)){
			error("Invalid assignment", FunPLPackage::eINSTANCE.assignment_Left, INVALID_ASSIGNMENT)
		}else if((_a.left as SymbolRef).symbol instanceof Function){
			error("Invalid assignment", FunPLPackage::eINSTANCE.assignment_Left, INVALID_ASSIGNMENT)
		}else if(!(_a.left as SymbolRef).symbol.typeFor.isSame(_a.right.typeFor)){
			error("The operation is undefined for argument type(s) " + _a.left.typeFor.typeString + ", " + _a.right.typeFor.typeString , 
				null, 
				INVALID_ASSIGNMENT
			)
		}
		
	}
	
	@Check
	def void checkPlusExpressionValidity(Plus _p){
		if(!(_p.left.typeFor.isInt && _p.right.typeFor.isInt)){
			error("The operation is undefined for argument type(s) " + _p.left.typeFor.typeString + ", " + _p.right.typeFor.typeString + "!",
				null,
				INVALID_ADDITION
			)
		}
	}
	
	@Check
	def void checkFunctionReturnTypesSame(Function _f){
		val declaredOrFirst = _f.returnTypeFor
		val res = _f.returnStatements
		for(r : res){
			if(!r.typeFor.isSame(declaredOrFirst)){
				error("Multiple return types in function '" + _f.name + "'!",
					FunPLPackage::eINSTANCE.symbol_Name,
					AMBIGUOUS_RETURN_TYPE
				)
			}
		}
		
	}
	
	@Check
	def void checkFunctionHasReturnStatement(Function _f){	//TODO Sophisticate!
		val res = _f.returnStatements
		if(res.size == 0 && !_f.returnTypeFor.isVoid){
			error("Missing return statement in function '" + _f.name + "'!",
					FunPLPackage::eINSTANCE.symbol_Name,
					MISSING_RETURN_STATEMENT
				)
		}
	}
	
	///////////////////////////////////OTHER RULES/////////////////////////////////////////////
	
	@Check
	def void checkConstantReassignment(Assignment _a){
		if(_a.left instanceof SymbolRef){
			val _cRef = _a.left as SymbolRef
			if(_cRef.symbol instanceof Value){
				val _c = _cRef.symbol as Value
				if(_c.const){
					error("Constant-value reassignment not allowed: '" + _c.name + "'",
						FunPLPackage::eINSTANCE.assignment_Left,
						CONSTANT_REASSIGNMENT,
						_c.name
					)
				}
			}
		}
	}
	
	@Check
	def void checkUndefinedConstant(Value _v){
		if(_v.isConst){
			if(_v.expression === null){
				error("Undefined constant not allowed: '" + _v.name + "'",
					FunPLPackage::eINSTANCE.symbol_Name,
					UNDEFINED_CONSTANT,
					_v.name
				)
			}
		}
	}
	
	@Check
	def void checkFunctionCallValidity(FunctionCall _fc){
		if(_fc.args.size != _fc.function.params.size){
			error("The function call signature does not match any possible function definitions",
				null,
				INVALID_FUNCTION_CALL
			)
		}else{
			for(var i = 0; i < _fc.args.size; i++){
				if(!(_fc.args.get(i).typeFor.isSame(_fc.function.params.get(i).typeFor))){
					error("The function call signature does not match any possible function definitions",
							null,
							INVALID_FUNCTION_CALL
						)
				}
			}
		}
	}
	
	////////////////////////////////ADDITIONAL HELPER METHODS///////////////////////////////////////////
	
	def private boolean containsSameNamedSymbol(Iterable<? extends Symbol> _l, Symbol _s){
		val _it = _l.iterator
		while(_it.hasNext){
			if(_it.next.name == _s.name)
				return true
		}
		return false
	}
	
}
