/*
 * generated by Xtext 2.15.0
 */
package xyz.varad.funpl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import xyz.varad.funpl.funPL.ArgumentList;
import xyz.varad.funpl.funPL.AssignmentExpression;
import xyz.varad.funpl.funPL.Block;
import xyz.varad.funpl.funPL.BooleanLiteralExpression;
import xyz.varad.funpl.funPL.BooleanTypeDefinition;
import xyz.varad.funpl.funPL.FinalValueDeclaration;
import xyz.varad.funpl.funPL.FunPLPackage;
import xyz.varad.funpl.funPL.FunProgram;
import xyz.varad.funpl.funPL.FunctionDeclaration;
import xyz.varad.funpl.funPL.IntegerLiteralExpression;
import xyz.varad.funpl.funPL.IntegerTypeDefinition;
import xyz.varad.funpl.funPL.ParameterList;
import xyz.varad.funpl.funPL.PlusExpression;
import xyz.varad.funpl.funPL.ReferenceExpression;
import xyz.varad.funpl.funPL.ReturnStatement;
import xyz.varad.funpl.funPL.ValueDeclaration;
import xyz.varad.funpl.funPL.VoidTypeDefinition;
import xyz.varad.funpl.services.FunPLGrammarAccess;

@SuppressWarnings("all")
public class FunPLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FunPLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FunPLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FunPLPackage.ARGUMENT_LIST:
				sequence_ArgumentList(context, (ArgumentList) semanticObject); 
				return; 
			case FunPLPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case FunPLPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case FunPLPackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case FunPLPackage.BOOLEAN_TYPE_DEFINITION:
				sequence_BooleanTypeDefinition(context, (BooleanTypeDefinition) semanticObject); 
				return; 
			case FunPLPackage.FINAL_VALUE_DECLARATION:
				sequence_ParameterDeclaration(context, (FinalValueDeclaration) semanticObject); 
				return; 
			case FunPLPackage.FUN_PROGRAM:
				sequence_FunProgram(context, (FunProgram) semanticObject); 
				return; 
			case FunPLPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case FunPLPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case FunPLPackage.INTEGER_TYPE_DEFINITION:
				sequence_IntegerTypeDefinition(context, (IntegerTypeDefinition) semanticObject); 
				return; 
			case FunPLPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case FunPLPackage.PLUS_EXPRESSION:
				sequence_PlusExpression(context, (PlusExpression) semanticObject); 
				return; 
			case FunPLPackage.REFERENCE_EXPRESSION:
				sequence_ReferenceExpression(context, (ReferenceExpression) semanticObject); 
				return; 
			case FunPLPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case FunPLPackage.VALUE_DECLARATION:
				sequence_ValueDeclaration(context, (ValueDeclaration) semanticObject); 
				return; 
			case FunPLPackage.VOID_TYPE_DEFINITION:
				sequence_VoidTypeDefinition(context, (VoidTypeDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArgumentList returns ArgumentList
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 */
	protected void sequence_ArgumentList(ISerializationContext context, ArgumentList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentExpression
	 *     Expression returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns AssignmentExpression
	 *     PlusExpression returns AssignmentExpression
	 *     PlusExpression.PlusExpression_1_0 returns AssignmentExpression
	 *     PrimaryExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=AssignmentExpression_AssignmentExpression_1_0 right=Expression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BooleanTypeDefinition
	 *     TypeDefinition returns BooleanTypeDefinition
	 *     BooleanTypeDefinition returns BooleanTypeDefinition
	 *
	 * Constraint:
	 *     {BooleanTypeDefinition}
	 */
	protected void sequence_BooleanTypeDefinition(ISerializationContext context, BooleanTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunProgram returns FunProgram
	 *
	 * Constraint:
	 *     ((name=QualifiedName elements+=AbstractElement+) | elements+=AbstractElement+)?
	 */
	protected void sequence_FunProgram(ISerializationContext context, FunProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns FunctionDeclaration
	 *     Declaration returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (declaredType=Type? name=ID parameterList=ParameterList body=Block)
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntegerTypeDefinition
	 *     TypeDefinition returns IntegerTypeDefinition
	 *     IntegerTypeDefinition returns IntegerTypeDefinition
	 *
	 * Constraint:
	 *     {IntegerTypeDefinition}
	 */
	protected void sequence_IntegerTypeDefinition(ISerializationContext context, IntegerTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BooleanLiteralExpression
	 *     Expression returns BooleanLiteralExpression
	 *     AssignmentExpression returns BooleanLiteralExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns BooleanLiteralExpression
	 *     PlusExpression returns BooleanLiteralExpression
	 *     PlusExpression.PlusExpression_1_0 returns BooleanLiteralExpression
	 *     PrimaryExpression returns BooleanLiteralExpression
	 *     TerminalExpression returns BooleanLiteralExpression
	 *     LiteralExpression returns BooleanLiteralExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, BooleanLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueBOOLEANTerminalRuleCall_1_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntegerLiteralExpression
	 *     Expression returns IntegerLiteralExpression
	 *     AssignmentExpression returns IntegerLiteralExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns IntegerLiteralExpression
	 *     PlusExpression returns IntegerLiteralExpression
	 *     PlusExpression.PlusExpression_1_0 returns IntegerLiteralExpression
	 *     PrimaryExpression returns IntegerLiteralExpression
	 *     TerminalExpression returns IntegerLiteralExpression
	 *     LiteralExpression returns IntegerLiteralExpression
	 *
	 * Constraint:
	 *     value=INTEGER
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, IntegerLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueINTEGERTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclaration returns FinalValueDeclaration
	 *
	 * Constraint:
	 *     (declaredType=Type name=ID expression=Expression?)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, FinalValueDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=ParameterDeclaration parameters+=ParameterDeclaration*)?
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlusExpression
	 *     Expression returns PlusExpression
	 *     AssignmentExpression returns PlusExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PlusExpression
	 *     PlusExpression returns PlusExpression
	 *     PlusExpression.PlusExpression_1_0 returns PlusExpression
	 *     PrimaryExpression returns PlusExpression
	 *
	 * Constraint:
	 *     (left=PlusExpression_PlusExpression_1_0 right=PrimaryExpression)
	 */
	protected void sequence_PlusExpression(ISerializationContext context, PlusExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FunPLPackage.Literals.BINARY_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusExpressionAccess().getPlusExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusExpressionAccess().getRightPrimaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReferenceExpression
	 *     Expression returns ReferenceExpression
	 *     AssignmentExpression returns ReferenceExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ReferenceExpression
	 *     PlusExpression returns ReferenceExpression
	 *     PlusExpression.PlusExpression_1_0 returns ReferenceExpression
	 *     PrimaryExpression returns ReferenceExpression
	 *     TerminalExpression returns ReferenceExpression
	 *     ReferenceExpression returns ReferenceExpression
	 *
	 * Constraint:
	 *     (declaration=[Declaration|QualifiedName] argumentList=ArgumentList?)
	 */
	protected void sequence_ReferenceExpression(ISerializationContext context, ReferenceExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns ValueDeclaration
	 *     Declaration returns ValueDeclaration
	 *     OuterValueDeclaration returns ValueDeclaration
	 *     ValueDeclaration returns ValueDeclaration
	 *     Statement returns ValueDeclaration
	 *
	 * Constraint:
	 *     (constant?='const'? declaredType=Type? name=ID expression=Expression?)
	 */
	protected void sequence_ValueDeclaration(ISerializationContext context, ValueDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns VoidTypeDefinition
	 *     TypeDefinition returns VoidTypeDefinition
	 *     VoidTypeDefinition returns VoidTypeDefinition
	 *
	 * Constraint:
	 *     {VoidTypeDefinition}
	 */
	protected void sequence_VoidTypeDefinition(ISerializationContext context, VoidTypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
