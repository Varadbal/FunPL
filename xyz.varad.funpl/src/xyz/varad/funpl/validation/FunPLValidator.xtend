/*
 * generated by Xtext 2.14.0
 */
package xyz.varad.funpl.validation

import org.eclipse.xtext.validation.Check
import com.google.inject.Inject
import xyz.varad.funpl.util.FunPLModelUtil
import xyz.varad.funpl.funPL.FunPLPackage
import xyz.varad.funpl.funPL.SymbolRef
import xyz.varad.funpl.funPL.Symbol
import xyz.varad.funpl.funPL.Definition
import static extension xyz.varad.funpl.util.FunPLModelUtil.*

import static extension org.eclipse.xtext.EcoreUtil2.*
import xyz.varad.funpl.funPL.Function
import xyz.varad.funpl.funPL.FunProgram
import java.util.List
import xyz.varad.funpl.funPL.Value
import xyz.varad.funpl.funPL.FunctionParam
import xyz.varad.funpl.funPL.Assignment

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FunPLValidator extends AbstractFunPLValidator {
	// TODO const reassignment
	// TODO function call #args=#params
	// TODO disable def. references in global scope???
	
	static val ISSUE_CODE_PREFIX = "xyz.varad.funpl."
	//public static val FORWARD_REFERENCE = ISSUE_CODE_PREFIX + "ForwardReference"
	public static val SYMBOL_REDEFINITION = ISSUE_CODE_PREFIX + "SymbolRedefinition"
	public static val UNDEFINED_CONSTANT = ISSUE_CODE_PREFIX + "UndefinedConstant"
	public static val CONSTANT_REASSIGNMENT = ISSUE_CODE_PREFIX + "ConstantReassignment"
	
	//@Inject extension FunPLModelUtil
	
	/* //Forward Reference - Scoping Solved That 
	@Check
	def void checkForwardReference(SymbolRef _sym){
		val symbol = _sym.symbol
		if(symbol !== null && !_sym.isDefinedBefore){
			error("Symbol forward reference not allowed: '" + symbol.name + "'",
				FunPLPackage::eINSTANCE.symbolRef_Symbol,
				FORWARD_REFERENCE,
				symbol.name
			)
		}
	}
	*/
	
	@Check
	def void checkSymbolRedefinitionAsNeighbor(Definition _d){
		val contProg = _d.getContainerOfType(FunProgram)
		val contFunc = _d.getContainerOfType(Function)
		if(contFunc !== null && !(_d instanceof Function)){
			if(contFunc.symbols.takeWhile[it != _d].containsSameNamedSymbol(_d)){
				error("Symbol redefinition not allowed: '" + _d.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_d.name)
			}
		}else{
			if(contProg.symbols.takeWhile[it != _d].containsSameNamedSymbol(_d)){
				error("Symbol redefinition not allowed: '" + _d.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_d.name)
			}
		}
	}
	
	@Check
	def void checkSymbolRedefinitionParam(FunctionParam _p){
		val contFunc = _p.getContainerOfType(Function)
		if(contFunc !== null){
			if(contFunc.params.takeWhile[it != _p].containsSameNamedSymbol(_p)){
				error("Symbol redefinition not allowed: '" + _p.name + "'",
				FunPLPackage::eINSTANCE.symbol_Name,
				SYMBOL_REDEFINITION,
				_p.name)
			}
		}
	}
	
	@Check
	def void checkUndefinedConstant(Value _v){
		if(_v.isConst){
			if(_v.expression === null){
				error("Undefined constant not allowed: '" + _v.name + "'",
					FunPLPackage::eINSTANCE.symbol_Name,
					UNDEFINED_CONSTANT,
					_v.name
				)
			}
		}
	}
	
	@Check
	def void checkConstantReassignment(Assignment _a){
		
	}
	
	
	
	def private boolean containsSameNamedSymbol(Iterable<? extends Symbol> _l, Symbol _s){
		val _it = _l.iterator
		while(_it.hasNext){
			if(_it.next.name == _s.name)
				return true
		}
		return false
	}
	
}
