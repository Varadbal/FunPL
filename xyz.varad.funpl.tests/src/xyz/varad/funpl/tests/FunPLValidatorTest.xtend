/*
 * generated by Xtext 2.14.0
 */
package xyz.varad.funpl.tests

import com.google.inject.Inject
import static extension org.junit.Assert.*
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith
import xyz.varad.funpl.funPL.FunPLPackage
import xyz.varad.funpl.funPL.FunProgram
import xyz.varad.funpl.validation.FunPLValidator

@RunWith(XtextRunner)
@InjectWith(FunPLInjectorProvider)
class FunPLValidatorTest {
	
	@Inject extension ParseHelper<FunProgram> 
	@Inject extension ValidationTestHelper
	
	
	@Test
	def void testForwardReference(){		
		'''
		var i = j;
		var j = 10;
		function myFunc(){
			
		}
		'''.parse => [
			assertTrue((validate.size == 1) && (validate.head.message == "Couldn't resolve reference to Symbol 'j'."))	//Forward reference error from scoping
			//assertError(FunPLPackage::eINSTANCE.symbolRef, FunPLValidator::FORWARD_REFERENCE, "Symbol forward reference not allowed: 'j'")
		]
	}
	
	@Test
	def void testForwardReferenceLocal(){		
		'''
		function myFunc()
		{
			var i = j;
			var j = 10;
		}
		'''.parse => [
			assertTrue((validate.size == 1) && (validate.head.message == "Couldn't resolve reference to Symbol 'j'."))	//Forward reference error from scoping
			//assertError(FunPLPackage::eINSTANCE.symbolRef, FunPLValidator::FORWARD_REFERENCE, "Symbol forward reference not allowed: 'j'")
		]
	}
	
	@Test
	def void testGlobalRedefinitionLocally(){
		'''
		var i = 4;
		function myFunc(int p){
			var i = 5;
		}
		'''.parse => [
			assertNoErrors
		]
	}
	
	@Test
	def void testGlobalRedefinitionGlobally(){
		'''
		var i = 4;
		function myFunc(){ }
		const i = 5;
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'i'"
			)
		]
		
		'''
		var i = 4;
		function myFunc(){
			
		}
		function myFunc() {
			
		}
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.function,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'myFunc'"
			)
		]

	}
	
	@Test 
	def void testLocalRedefinition(){
		'''
		function myFunc(int p){
			var i = 5;
			var i = 2;
		}
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.value, FunPLValidator::SYMBOL_REDEFINITION, "Symbol redefinition not allowed: 'i'")
		]
	}
	
	@Test
	def void testOutOfScopeRedefinition(){
		'''
		function myFunc(int p){
			var i = 5;
		}
		function myFunc2(){
			var i = 1;
		}
		'''.parse.assertNoErrors
	}
	
	@Test
	def void testParameterRedefinition(){
		'''
		function myFunc(int p){
			var p = 5;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'p'"
			)
	}
	
	@Test
	def void testParameterRedefinitionAsParam(){
		'''
		function myFunc(int p1,int p1){
			
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.functionParam,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'p1'"
			)
	}
	
	@Test
	def void testInvalidAssignment(){
		'''
		function myFunc(){
			5 = 2;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_ASSIGNMENT,
			"Invalid assignment"
			)
		
		'''
		function foo(){
			
		}
		function bar(){
			foo = 2;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_ASSIGNMENT,
			"Invalid assignment"
			)
	}
	
	@Test
	def void testConstantReassignment(){
		'''
		function foo(){
			const m = 5;
			m = 6;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::CONSTANT_REASSIGNMENT,
			"Constant-value reassignment not allowed: 'm'"
			)
	}
	
	@Test
	def void testUndefinedConstant(){
		'''
		const i;
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::UNDEFINED_CONSTANT,
			"Undefined constant not allowed: 'i'"
			)
			
		'''
		const i = 1;
		'''.parse.assertNoErrors
	}
	
	
	
}
