/**
 * generated by Xtext 2.14.0
 */
package xyz.varad.funpl.tests;

import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import xyz.varad.funpl.funPL.AbstractElement;
import xyz.varad.funpl.funPL.Assignment;
import xyz.varad.funpl.funPL.BoolConstant;
import xyz.varad.funpl.funPL.BoolTypeDefinition;
import xyz.varad.funpl.funPL.Expression;
import xyz.varad.funpl.funPL.FunProgram;
import xyz.varad.funpl.funPL.Function;
import xyz.varad.funpl.funPL.FunctionCall;
import xyz.varad.funpl.funPL.IntConstant;
import xyz.varad.funpl.funPL.IntTypeDefinition;
import xyz.varad.funpl.funPL.Plus;
import xyz.varad.funpl.funPL.Statement;
import xyz.varad.funpl.funPL.StringConstant;
import xyz.varad.funpl.funPL.StringTypeDefinition;
import xyz.varad.funpl.funPL.Symbol;
import xyz.varad.funpl.funPL.SymbolRef;
import xyz.varad.funpl.funPL.Type;
import xyz.varad.funpl.funPL.Value;
import xyz.varad.funpl.tests.FunPLInjectorProvider;

@RunWith(XtextRunner.class)
@InjectWith(FunPLInjectorProvider.class)
@SuppressWarnings("all")
public class FunPLParsingTest {
  @Inject
  @Extension
  private ParseHelper<FunProgram> _parseHelper;
  
  @Inject
  @Extension
  private ValidationTestHelper _validationTestHelper;
  
  @Test
  public void testValueDeclaration() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("var i;");
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("var i = 5;");
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder_1));
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("var i = 3;");
      _builder_2.newLine();
      _builder_2.append("const j = i;");
      _builder_2.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder_2));
      StringConcatenation _builder_3 = new StringConcatenation();
      _builder_3.append("var int i = 3;");
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder_3));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testFunctionDefinition() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(int p1, bool p2, string p3){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testFunctionLocalVariable() {
    this.testFunctionLocal("var i = 5;");
    this.testFunctionLocal("const i = \'asd\';");
    this.testFunctionLocal("var i = v;");
    this.testFunctionLocal("const i = v;");
  }
  
  @Test
  public void testFunctionLocalExpression() {
    this.testFunctionLocal("a = 2;");
    this.testFunctionLocal("a = b = v = 3;");
    this.testFunctionLocal("5 + 5;");
    this.testFunctionLocal("5 + v + 3 + c;");
    this.testFunctionLocal("(1 + 2);");
    this.testFunctionLocal("1 + (2 + (3 + 4));");
    this.testFunctionLocal("5;");
    this.testFunctionLocal("\'asd\';");
    this.testFunctionLocal("true;");
  }
  
  @Test
  public void testFunctionCallExpression() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var i = 5;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc();");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc2(1, 2);");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc3(1, 1, 5);");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc3(1 + 2, 1 + (3 + 4), i = 2);");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("function myFunc2(int p1, bool p2){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("function myFunc3(int p1, bool p2, string p3){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void testFunctionLocal(final CharSequence toInsert) {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(int p1, int p2){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var a;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var b;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var v = 1;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("const c = 2;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append(toInsert, "\t");
      _builder.newLineIfNotEmpty();
      _builder.append("}");
      _builder.newLine();
      this._validationTestHelper.assertNoErrors(this._parseHelper.parse(_builder));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testAssignmentAssociativity() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var i = 2;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("i = 3;\t\t//(1)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var j = 5;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("i = j = 2;\t//(3)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("(i = j) = 2\t//(4)");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      AbstractElement _get = this._parseHelper.parse(_builder).getElements().get(0);
      final Procedure1<Function> _function = (Function it) -> {
        this.assertAssociativity(it.getBody().getStatements().get(1), "(i = 3)");
        this.assertAssociativity(it.getBody().getStatements().get(3), "(i = (j = 2))");
        this.assertAssociativity(it.getBody().getStatements().get(4), "((i = j) = 2)");
      };
      ObjectExtensions.<Function>operator_doubleArrow(
        ((Function) _get), _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testPlusAssociativity() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("5 + 5;\t\t//(0)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("5 + 5 + 5;\t//(1)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("5 + (5 + 5);//(2)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var i = 2;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("3 + i + 2\t//(4)");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      AbstractElement _head = IterableExtensions.<AbstractElement>head(this._parseHelper.parse(_builder).getElements());
      final Procedure1<Function> _function = (Function it) -> {
        this.assertAssociativity(it.getBody().getStatements().get(0), "(5 + 5)");
        this.assertAssociativity(it.getBody().getStatements().get(1), "((5 + 5) + 5)");
        this.assertAssociativity(it.getBody().getStatements().get(2), "(5 + (5 + 5))");
        this.assertAssociativity(it.getBody().getStatements().get(4), "((3 + i) + 2)");
      };
      ObjectExtensions.<Function>operator_doubleArrow(
        ((Function) _head), _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testFunctionCallAssociativity() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc2(1, 2);");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc2(1, myFunc2(myFunc2(1, 1), 2));\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("function myFunc2(int p1, int p2){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      AbstractElement _head = IterableExtensions.<AbstractElement>head(this._parseHelper.parse(_builder).getElements());
      final Procedure1<Function> _function = (Function it) -> {
        this.assertAssociativity(it.getBody().getStatements().get(0), "(myFunc2(1, 2))");
        this.assertAssociativity(it.getBody().getStatements().get(1), "(myFunc2(1, (myFunc2((myFunc2(1, 1)), 2))))");
      };
      ObjectExtensions.<Function>operator_doubleArrow(
        ((Function) _head), _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testMixedAssociativity() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function myFunc(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var i = 5;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("const j = \"myString\";");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("var k = true;");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("myFunc2(myFunc2(2 + i, i + j + k + myFunc3(i = 3, k, 1 + (i + j))), myFunc3(k = false, 1 , 2))");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("function myFunc2(int p1, int p2){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("function myFunc3(int p1, int p2, int p3){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      AbstractElement _head = IterableExtensions.<AbstractElement>head(this._parseHelper.parse(_builder).getElements());
      final Procedure1<Function> _function = (Function it) -> {
        this.assertAssociativity(it.getBody().getStatements().get(3), "(myFunc2((myFunc2((2 + i), (((i + j) + k) + (myFunc3((i = 3), k, (1 + (i + j))))))), (myFunc3((k = false), 1, 2))))");
      };
      ObjectExtensions.<Function>operator_doubleArrow(
        ((Function) _head), _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testValueTypes() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("var int i = 1;");
      _builder.newLine();
      _builder.append("const bool j = true;");
      _builder.newLine();
      _builder.append("var string k = \"sajt\";");
      _builder.newLine();
      _builder.append("var m;");
      _builder.newLine();
      _builder.append("var ins n;");
      _builder.newLine();
      FunProgram _parse = this._parseHelper.parse(_builder);
      final Procedure1<FunProgram> _function = (FunProgram it) -> {
        AbstractElement _get = it.getElements().get(0);
        this.assertSymbolType(((Symbol) _get), IntTypeDefinition.class);
        AbstractElement _get_1 = it.getElements().get(1);
        this.assertSymbolType(((Symbol) _get_1), BoolTypeDefinition.class);
        AbstractElement _get_2 = it.getElements().get(2);
        this.assertSymbolType(((Symbol) _get_2), StringTypeDefinition.class);
        AbstractElement _get_3 = it.getElements().get(3);
        this.assertSymbolType(((Symbol) _get_3), null);
      };
      ObjectExtensions.<FunProgram>operator_doubleArrow(_parse, _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testFunctionTypes() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function int foo(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("function bool bar(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("function string baz(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("function bax(){");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      FunProgram _parse = this._parseHelper.parse(_builder);
      final Procedure1<FunProgram> _function = (FunProgram it) -> {
        AbstractElement _get = it.getElements().get(0);
        this.assertSymbolType(((Symbol) _get), IntTypeDefinition.class);
        AbstractElement _get_1 = it.getElements().get(1);
        this.assertSymbolType(((Symbol) _get_1), BoolTypeDefinition.class);
        AbstractElement _get_2 = it.getElements().get(2);
        this.assertSymbolType(((Symbol) _get_2), StringTypeDefinition.class);
        AbstractElement _get_3 = it.getElements().get(3);
        this.assertSymbolType(((Symbol) _get_3), null);
      };
      ObjectExtensions.<FunProgram>operator_doubleArrow(_parse, _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void testFunctionParamTypes() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function foo(int p1, bool p2, string p3) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      AbstractElement _head = IterableExtensions.<AbstractElement>head(this._parseHelper.parse(_builder).getElements());
      final Procedure1<Function> _function = (Function it) -> {
        this.assertSymbolType(it.getParams().get(0), IntTypeDefinition.class);
        this.assertSymbolType(it.getParams().get(1), BoolTypeDefinition.class);
        this.assertSymbolType(it.getParams().get(2), StringTypeDefinition.class);
      };
      ObjectExtensions.<Function>operator_doubleArrow(
        ((Function) _head), _function);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private void assertSymbolType(final Symbol v, final Class<? extends Type> t) {
    if ((t == null)) {
      Assert.assertEquals(v.getType(), null);
    } else {
      Assert.assertTrue(t.isInstance(v.getType()));
    }
  }
  
  private void assertAssociativity(final Statement s, final CharSequence expected) {
    Assert.assertEquals(expected.toString(), FunPLParsingTest.stringRepr(s));
  }
  
  static String stringRepr(final Statement s) {
    String _switchResult = null;
    boolean _matched = false;
    if (s instanceof Assignment) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("(");
      String _stringRepr = FunPLParsingTest.stringRepr(((Assignment)s).getLeft());
      _builder.append(_stringRepr);
      _builder.append(" = ");
      String _stringRepr_1 = FunPLParsingTest.stringRepr(((Assignment)s).getRight());
      _builder.append(_stringRepr_1);
      _builder.append(")");
      _switchResult = _builder.toString();
    }
    if (!_matched) {
      if (s instanceof Plus) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("(");
        String _stringRepr = FunPLParsingTest.stringRepr(((Plus)s).getLeft());
        _builder.append(_stringRepr);
        _builder.append(" + ");
        String _stringRepr_1 = FunPLParsingTest.stringRepr(((Plus)s).getRight());
        _builder.append(_stringRepr_1);
        _builder.append(")");
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (s instanceof FunctionCall) {
        _matched=true;
        String _name = ((FunctionCall)s).getFunction().getName();
        String _plus = ("(" + _name);
        String ret = (_plus + "(");
        EList<Expression> _args = ((FunctionCall)s).getArgs();
        for (final Expression a : _args) {
          {
            String _ret = ret;
            String _stringRepr = FunPLParsingTest.stringRepr(a);
            ret = (_ret + _stringRepr);
            Expression _last = IterableExtensions.<Expression>last(((FunctionCall)s).getArgs());
            boolean _tripleNotEquals = (a != _last);
            if (_tripleNotEquals) {
              String _ret_1 = ret;
              ret = (_ret_1 + ", ");
            }
          }
        }
        String _ret = ret;
        ret = (_ret + "))");
        return ret;
      }
    }
    if (!_matched) {
      if (s instanceof IntConstant) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        int _value = ((IntConstant)s).getValue();
        _builder.append(_value);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (s instanceof StringConstant) {
        _matched=true;
        _switchResult = ((StringConstant)s).getValue();
      }
    }
    if (!_matched) {
      if (s instanceof BoolConstant) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _value = ((BoolConstant)s).getValue();
        _builder.append(_value);
        _switchResult = _builder.toString();
      }
    }
    if (!_matched) {
      if (s instanceof SymbolRef) {
        _matched=true;
        _switchResult = ((SymbolRef)s).getSymbol().getName();
      }
    }
    if (!_matched) {
      if (s instanceof Value) {
        _matched=true;
        String ret = "";
        boolean _isConst = ((Value)s).isConst();
        if (_isConst) {
          String _ret = ret;
          ret = (_ret + "const ");
        } else {
          String _ret_1 = ret;
          ret = (_ret_1 + "var ");
        }
        String _ret_2 = ret;
        String _name = ((Value)s).getName();
        ret = (_ret_2 + _name);
        Expression _expression = ((Value)s).getExpression();
        boolean _tripleNotEquals = (_expression != null);
        if (_tripleNotEquals) {
          String _ret_3 = ret;
          ret = (_ret_3 + " = ");
          String _ret_4 = ret;
          String _stringRepr = FunPLParsingTest.stringRepr(((Value)s).getExpression());
          ret = (_ret_4 + _stringRepr);
        }
        return ret;
      }
    }
    return _switchResult;
  }
}
