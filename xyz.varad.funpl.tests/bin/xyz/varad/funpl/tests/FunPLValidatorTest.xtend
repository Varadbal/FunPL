/*
 * generated by Xtext 2.14.0
 */
package xyz.varad.funpl.tests

import com.google.inject.Inject
import static extension org.junit.Assert.*
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith
import xyz.varad.funpl.funPL.FunPLPackage
import xyz.varad.funpl.funPL.FunProgram
import xyz.varad.funpl.validation.FunPLValidator

@RunWith(XtextRunner)
@InjectWith(FunPLInjectorProvider)
class FunPLValidatorTest {
	
	@Inject extension ParseHelper<FunProgram> 
	@Inject extension ValidationTestHelper
	
	////////////////////////////////////////////////SCOPING-RELATED TESTS//////////////////////////////////////////////
	
	@Test
	def void testForwardReference(){		
		'''
		var i = j;
		var j = 10;
		function myFunc(){
			
		}
		'''.parse => [
			assertTrue((validate.size == 2) && (validate.head.message == "Couldn't resolve reference to Symbol 'j'."))	
			//Forward reference error from scoping + type error from validator
		]
	}
	
	@Test
	def void testForwardReferenceLocal(){		
		'''
		function myFunc()
		{
			var i = j;
			var j = 10;
		}
		'''.parse => [
			assertTrue((validate.size == 2) && (validate.head.message == "Couldn't resolve reference to Symbol 'j'."))	
			//Forward reference error from scoping + type error from validator
		]
	}
	
	@Test
	def void testGlobalRedefinitionLocally(){
		'''
		var i = 4;
		function myFunc(int p){
			var i = 5;
		}
		'''.parse => [
			assertNoErrors
		]
	}
	
	@Test
	def void testGlobalRedefinitionGlobally(){
		'''
		var i = 4;
		function myFunc(){ }
		const i = 5;
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'i'"
			)
		]
		
		'''
		var i = 4;
		function myFunc(){
			
		}
		function myFunc() {
			
		}
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.function,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'myFunc'"
			)
		]

	}
	
	@Test 
	def void testLocalRedefinition(){
		'''
		function myFunc(int p){
			var i = 5;
			var i = 2;
		}
		'''.parse => [
			assertError(FunPLPackage::eINSTANCE.value, FunPLValidator::SYMBOL_REDEFINITION, "Symbol redefinition not allowed: 'i'")
		]
	}
	
	@Test
	def void testOutOfScopeRedefinition(){
		'''
		function myFunc(int p){
			var i = 5;
		}
		function myFunc2(){
			var i = 1;
		}
		'''.parse.assertNoErrors
	}
	
	@Test
	def void testParameterRedefinition(){
		'''
		function myFunc(int p){
			var p = 5;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'p'"
			)
	}
	
	@Test
	def void testParameterRedefinitionAsParam(){
		'''
		function myFunc(int p1,int p1){
			
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.functionParam,
			FunPLValidator::SYMBOL_REDEFINITION,
			"Symbol redefinition not allowed: 'p1'"
			)
	}
	
	/////////////////////////////EXPRESSION AND TYPING TESTS/////////////////////////////////////////////////////
	
	@Test
	def void testValueDefinitionValidity(){
		'''
		var int i = "asd";
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::INVALID_VALUE_DEFINITION,
			"The operation is undefined for argument type(s) int, string"
		)
		
		'''
		var i = "asd";
		'''.parse.assertNoErrors
		
		'''
		var i;
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::INVALID_VALUE_DEFINITION,
			"The value 'i' must either have a declared type or be initialized"
		)
	}
	
	@Test
	def void testInvalidAssignment(){
		'''
		function myFunc(){
			5 = 2;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_ASSIGNMENT,
			"Invalid assignment"
			)
		
		'''
		function foo(){
			
		}
		function bar(){
			foo = 2;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_ASSIGNMENT,
			"Invalid assignment"
			)
			
		'''
		function foo(){
			var int i = 5;
			i = true;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_ASSIGNMENT,
			"The operation is undefined for argument type(s) int, bool"
		)
	}

	@Test
	def void testInvalidAddition(){
		'''
		function foo(){
			5 + "a";
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.expression,
			FunPLValidator::INVALID_ADDITION,
			"The operation is undefined for argument type(s) int, string!"
		)
		
		'''
		var i = 5 + true;
		'''.parse.assertError(FunPLPackage::eINSTANCE.expression,
			FunPLValidator::INVALID_ADDITION,
			"The operation is undefined for argument type(s) int, bool!"
			)
	}
	
	@Test
	def void testFunctionReturnTypesSame(){
		'''
		function foo(){
			return 5;
			return;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.function,
			FunPLValidator::AMBIGUOUS_RETURN_TYPE,
			"Multiple return types in function 'foo'"
		)
		
		'''
		function string foo(){
			return 5;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.function,
			FunPLValidator::AMBIGUOUS_RETURN_TYPE,
			"Multiple return types in function 'foo'"
		)
		
		'''
		function int foo(){
			return 5;
		}
		'''.parse.assertNoErrors
		
		'''
		function foo(){
			return;
		}
		'''.parse.assertNoErrors
		
	}
	
	@Test
	def void testFunctionHasReturnStatement(){
		'''
		function int foo(){
			
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.function,
			FunPLValidator::MISSING_RETURN_STATEMENT,
			"Missing return statement in function 'foo'"
		)
		
		'''
		function foo(){
			
		}
		'''.parse.assertNoErrors
	}
	
	///////////////////////////////////////OTHER TESTS/////////////////////////////////////////////////////////
	
	@Test
	def void testConstantReassignment(){
		'''
		function foo(){
			const m = 5;
			m = 6;
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::CONSTANT_REASSIGNMENT,
			"Constant-value reassignment not allowed: 'm'"
			)
	}
	
	@Test
	def void testUndefinedConstant(){
		'''
		const i;
		'''.parse.assertError(FunPLPackage::eINSTANCE.value,
			FunPLValidator::UNDEFINED_CONSTANT,
			"Undefined constant not allowed: 'i'"
			)
			
		'''
		const i = 1;
		'''.parse.assertNoErrors
	}
	
	@Test
	def void testFunctionCallValidity(){
		'''
		function foo(int p1, int p2){
			
		}
		function bar(){
			foo(5);
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_FUNCTION_CALL,
			"The function call signature does not match any possible function definitions"
		)
		
		'''
		function foo(int p1, bool p2, string p3){
			
		}
		function bar(){
			foo(5, 5, 5);
		}
		'''.parse.assertError(FunPLPackage::eINSTANCE.statement,
			FunPLValidator::INVALID_FUNCTION_CALL,
			"The function call signature does not match any possible function definitions"
		)
		
		'''
		function foo(int p1, bool p2, string p3){
			
		}
		function bar(){
			foo(5, false, "asddsa");
		}
		'''.parse.assertNoErrors
	}
	
	
}
